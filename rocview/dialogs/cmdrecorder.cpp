/* Rocrail - Model Railroad Software Copyright (C) 2002-2013 Rob Versluis, Rocrail.net Without an official permission commercial use is not permitted. Forking this project is not permitted. This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version. This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.*/#include "cmdrecorder.h"#include "rocs/public/strtok.h"#include "rocview/symbols/svg.h"#include "rocview/public/base.h"#include "rocview/res/icons.hpp"#include "rocview/public/guiapp.h"#include "rocrail/public/script.h"CmdRecorder::CmdRecorder( wxWindow* parent )  :CmdRecorderGen( parent ){  m_Stop->SetBitmapLabel(*_img_stop);  m_Pause->SetBitmapLabel(*_img_pause);  m_Record->SetBitmapLabel(*_img_record);  m_Play->SetBitmapLabel(*_img_play);  GetSizer()->Layout();  GetSizer()->Fit(this);  GetSizer()->SetSizeHints(this);  Boolean recording = ScriptOp.isRecording(wxGetApp().getScript());  m_Record->Enable( recording?false:true );  m_Play->Enable( recording?false:true );  m_Pause->Enable( recording?false:true );  m_CmdList->Clear();  const char* cmds = ScriptOp.base.toString(wxGetApp().getScript());  iOStrTok tok = StrTokOp.inst(cmds, '\n');  while( StrTokOp.hasMoreTokens(tok)) {    const char* cmd = StrTokOp.nextToken(tok);    m_CmdList->Append(wxString(cmd,wxConvUTF8));  }}void CmdRecorder::onRecord( wxCommandEvent& event ){  if( !ScriptOp.isRecording(wxGetApp().getScript()) ) {    ScriptOp.setRecording(wxGetApp().getScript(), True);    m_Record->Enable( false );    m_Play->Enable( false );    m_Pause->Enable( false );  }}void CmdRecorder::onStop( wxCommandEvent& event ){  if( ScriptOp.isRecording(wxGetApp().getScript()) ) {    ScriptOp.setRecording(wxGetApp().getScript(), False);    m_Record->Enable( true );    m_Play->Enable( true );    m_Pause->Enable( true );    m_CmdList->Clear();    const char* cmds = ScriptOp.base.toString(wxGetApp().getScript());    iOStrTok tok = StrTokOp.inst(cmds, '\n');    while( StrTokOp.hasMoreTokens(tok)) {      const char* cmd = StrTokOp.nextToken(tok);      m_CmdList->Append(wxString(cmd,wxConvUTF8));    }  }}void CmdRecorder::onPause( wxCommandEvent& event ){// TODO: Implement onPause}void CmdRecorder::onPlay( wxCommandEvent& event ){// TODO: Implement onPlay}void CmdRecorder::onCmdSelected( wxCommandEvent& event ){// TODO: Implement onCmdSelected}void CmdRecorder::onModify( wxCommandEvent& event ){// TODO: Implement onModify}void CmdRecorder::onDelete( wxCommandEvent& event ){// TODO: Implement onDelete}void CmdRecorder::onSend( wxCommandEvent& event ){// TODO: Implement onSend}void CmdRecorder::onOK( wxCommandEvent& event ){  Destroy();}void CmdRecorder::onClose( wxCloseEvent& event ){  Destroy();}